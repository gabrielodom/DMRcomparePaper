% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/3_RunBumphunter.R
\name{RunBumphunter}
\alias{RunBumphunter}
\title{Return Results from the \code{bumphunter} Function}
\usage{
RunBumphunter(betaVals_mat, labels_fct = factor(c(rep("Tumor", 7),
  rep("Normal", 7))), chromos_char, chromPosit_num, cpgLocation_df,
  pickCutoffQ_num, maxGap_int, B_int = 10, numCores = detectCores() - 1,
  dmr.sig.threshold = 0.05, min.cpgs = 5)
}
\arguments{
\item{betaVals_mat}{A matrix of beta values returned in the first entry of
the output from the \code{SimulateData} function, ordered by the CpGs. 
Note this dataset inlcudes all CpGs on the array.}

\item{labels_fct}{A factor vector of subject class labels. These should
match the observations contained in the columns of the \code{betaVals_mat}
matrix. Defaults to \code{factor(c(rep("Tumor", 7), rep("Normal", 7)))}}

\item{chromos_char}{A character vector for the chromosomes on which the CpGs are located}

\item{chromPosit_num}{A numeric vector for the locations of the CpGs}

\item{cpgLocation_df}{An annotation table that indicates locations of CpGs.
This data frame has CpG IDs as the rows with matching chromosome and
location info in the columns. Specifically, the columns are: \code{ILMNID}
 - the CpG ID; \code{chr} - the chromosome label; and \code{MAPINFO} -
the chromosome location. An example is given in the \code{\data\cpgLocation_df}
data set.}

\item{pickCutoffQ_num}{The quantile used for picking the cutoff using the
permutation distribution, passed to the \code{\link[bumphunter]{bumphunter}}
function.}

\item{maxGap_int}{The maximum location gap, passed to the
\code{\link[bumphunter]{bumphunter}} function.}

\item{B_int}{An integer denoting the number of resamples to use when
computing null distributions, passed to the
\code{\link[bumphunter]{bumphunter}} function.}

\item{numCores}{The number of computing cores for parallel execution, passed
to the \code{\link[doParallel]{registerDoParallel}} function. Defaults to
one less than the number of cores available on your machine, as detected
via the \code{\link[parallel]{detectCores}} function.}

\item{dmr.sig.threshold}{Significance level to select regions (with
\code{dmr.pval} less than the specified value) passed to the internal
\code{\link{StandardizeOutput}} function.}

\item{min.cpgs}{The minimum number of CpGs before we consider a DMR
significant, passed to the internal \code{\link{StandardizeOutput}}
function. Defaults to 5.}
}
\value{
A list of two elements: a data frame of \code{bumphunter} results
   to be standardized by the \code{\link{StandardizeOutput}}
   function and the computing time for the bumphunter method.
}
\description{
A wrapper function for the Bumphunter method as implemented in
   the \code{bumphunter} package, called internally by the
   \code{\link{WriteBumphunterResults}} function.
}
\examples{
# Called internally by the WriteBumphunterResults() function.
\dontrun{
   data("betaVals_mat")
   data("cpgLocation_df")
   data("startEndCPG_df")

   treat_ls <- SimulateData(beta_mat = betaVals_mat,
                            AclustCPG_df = startEndCPG_df,
                            delta_num = 0.4,
                            seed_int = 100)
   class_fct <- factor(c(rep("Tumor", 7), rep("Normal", 7)))

   RunBumphunter(
     betaVals_mat = treat_ls$simBetaVals_df,
     labels_fct = class_fct,
     cpgLocation_df = cpgLocation_df,
     pickCutoffQ_num = 0.95,
     maxGap_int = 250
   )
}

}
